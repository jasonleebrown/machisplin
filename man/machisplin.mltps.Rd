% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/ensemble.machine.learning.thin.plate.splines.V73.R
\name{machisplin.mltps}
\alias{machisplin.mltps}
\title{Machine Learning Ensemble & Thin-Plate-Spline Interpolation}
\usage{
machisplin.mltps(
  int.values,
  covar.ras,
  tps = TRUE,
  smooth.outputs.only = FALSE,
  trouble = FALSE
)
}
\arguments{
\item{int.values}{An data frame with the first two columns as coordinates of interpolated site named exactly as 'long' and 'lat', in this order, and any number of layers to downscale- each as a new column}

\item{tps}{if tps=TRUE then the residuals of the best model will be interpolated using a thin-plate-spline and the final downscaled layer will be adjusted by this layer (this is what ANUSPLIN does)}

\item{smooth.outputs.only}{if smooth.outputs.only=TRUE, this removes Boosted Regressive Trees and Random Forests for the options of algorithms.  Both occasionally produce 'blocky' outputs.  I always recommend first using smooth.outputs.only=FALSE for the intial analyses. Then if you are unhappy with the visual appearence of the created layers, consider smooth.outputs.only=TRUE. Be aware that now your model performance might dramatically decline because those two algorithms have been excluded}

\item{covar.ras=}{a raster or raster stack of high-resolution raster layers at resolution and extent of downscaling.  These layers will be used as co-variates and careful consideration should be given properly selecting these.}
}
\value{
This script interpolates noisy multi-variate data through machine learning ensembling using six algorithms: boosted regression trees (BRT), neural networks (NN); generalized additive model (GAM), multivariate adaptive regression splines (MARS), support vector machines (SVM) and random forests (RF). This function evaluates (via k-fold cross validation, where k=10) a methodâ€™s ability to predict the input data and ensembles of all combinations of the six algorithms weighting each from 0-1 and evaluting fit.  The best model will have the lowest AICc (with the number of parameters in AICc calculation corresponding the number of models in ensemble).  After the best model is determined, the function will run the ensemble on the full dataset.  Then residuals will be calculated and interpolated using thin-plate-smoothing splines, which will secondarily correct the final ensemble model. This package is a free open-source machine learning analog to the expensive ANUSPLIN software. To output final R2 values, model weights, algorithm(s) used, and rasters for use in GIS; use the 'machisplin.write.geotiff' function.  To output residuals use 'machisplin.write.residuals' and to output model loadings use 'machispline.write.loadings'.
}
\description{
Machine Learning Ensemble & Thin-Plate-Spline Interpolation
}
\examples{
######## EXAMPLE 1 ########
library(MACHISPLIN)
library(terra)
library(sp)

# Import a csv as shapefile:
Mydata<-read.delim("sampling.csv", sep=",", h=T)

#load rasters to use as high resolution co-variates for downscaling
ALT = terra::rast("SRTM30m.tif")
SLOPE = terra::rast("ln_slope.tif")
ASPECT = terra::rast("aspect.tif")
GEOMORPH = terra::rast("geomorphons.tif")
TWI = terra::rast("TWI.tif")

# function input: raster brick of covarites
raster_stack<-terra::c(ALT,SLOPE,TWI,GEOMORPH, ASPECT)

#run an ensemble machine learning thin plate spline 
interp.rast<-machisplin.mltps(int.values=Mydata, covar.ras=raster_stack, tps=FALSE)

#to plot results (change number to select different output raster)
plot(interp.rast[[1]]$final)

#to view residuals (change number to select different output raster)
interp.rast[[1]]$residuals

#to view model loadings
interp.rast[[1]]$var.imp

#to view other model parameters and other parameters
interp.rast[[1]]$summary

######## EXAMPLE 2 ########
library(MACHISPLIN)
library(terra)
library(sp)

##load spatial data with (coordinates named exactly as 'long' and 'lat') and any number of layers to downscale
data(sampling)
Mydata<-sampling

#load rasters to use as high resolution co-variates for downscaling
ALT = rast(system.file("extdata", "alt.tif", package="MACHISPLIN"))
SLOPE = rast(system.file("extdata", "slope.tif", package="MACHISPLIN"))
TWI = rast(system.file("extdata", "TWI.tif", package="MACHISPLIN"))

# function input: raster brick of covarites
raster_stack<-c(ALT,SLOPE,TWI)

#run an ensemble machine learning thin plate spline 
interp.rast<-machisplin.mltps(int.values=Mydata, covar.ras=raster_stack, smooth.outputs.only=TRUE)

machisplin.write.geotiff(mltps.in=interp.rast)
machisplin.write.residuals(mltps.in=interp.rast)
machisplin.write.loadings(mltps.in=interp.rast)


######## EXAMPLE 3 ########
library(MACHISPLIN)
library(terra)
library(sp)

# Import a csv as shapefile:
Mydata<-read.delim("sampling.csv", sep=",", h=T)

#load rasters to use as high resolution co-variates for downscaling
ALT = terra::rast("SRTM30m.tif")
SLOPE = terra::rast("ln_slope.tif")
ASPECT = terra::rast("aspect.tif")
GEOMORPH = terra::rast("geomorphons.tif")
TWI = terra::rast("TWI.tif")

# function input: raster brick of covarites
raster_stack<-terra::c(ALT,SLOPE,TWI,GEOMORPH, ASPECT)

# n of iterpolations - subtrack x and y
i.lyrs<-ncol(Mydata)-2

# a simple loop to iterate through your datafile, and as it finishes layers, it saves them.  This is nice in the event of errors 
for (i in 1:i.lyrs){
	  Mydat<-cbind(Mydata[1:2],Mydata[i+2])
      interp.rast<-machisplin.mltps(int.values=Mydat, covar.ras=raster_stack, smooth.outputs.only=TRUE, tps=TRUE)
	     machisplin.write.geotiff(mltps.in=interp.rast)
	     machisplin.write.residuals(mltps.in=interp.rast)
      machisplin.write.loadings(mltps.in=interp.rast)
  }
}
