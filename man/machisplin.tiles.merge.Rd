% Generated by roxygen2: do not edit by hand
% Please edit documentation in
%   R/ensemble.machine.learning.thin.plate.splines.V73.R
\name{machisplin.tiles.merge}
\alias{machisplin.tiles.merge}
\title{Merge multiple MACHISPLIN models}
\usage{
machisplin.tiles.merge(rast.in, rast.full.ext, in.ncol = 2, in.nrow = 3)
}
\arguments{
\item{rast.in}{a raster stack of high-resolution downscaled tited rasters output from the machisplin.mltps function}

\item{rast.full.ext}{a high-resolution raster brick at total extent (final) of all downscaling.  This should be the rast.in in used in the machisplin.tiles.create function.}

\item{out.ncol}{number of columns in the processing grid}

\item{out.nrow}{number of rows in the processing grid}
}
\value{
This function merges the high-resolution downscaled layers tiles output from  the machisplin.mltps function.  o
}
\description{
Merge multiple MACHISPLIN models
}
\examples{
########################################EXAMPLE 1################################################
library(MACHISPLIN)

# Import a csv 
Mydata	<-read.delim("sampling.csv", sep=",", h=T)

#load rasters to use as high resolution co-variates for downscaling
ALT = rast("SRTM30m.tif")
SLOPE = rast("ln_slope.tif")
ASPECT = rast("aspect.tif")
TWI = rast("TWI.tif")

# function input: raster stack of covarites
raster_stack<-c(ALT,SLOPE,TWI,ASPECT)

#sub-divide landscape into smaller units to facilite downscaling
tile<-machisplin.tile.landscape(rast.in= raster_stack, int.values=Mydata,out.ncol=2, out.nrow=2, feather.d=50)

#run an ensemble machine learning thin plate spline - tile 1:4
interp.rast.1<-machisplin.mltps(int.values=tile$dat[[1]], covar.ras=tile$rast[[1]], tps=TRUE)
interp.rast.2<-machisplin.mltps(int.values=tile$dat[[2]], covar.ras=tile$rast[[2]], tps=TRUE)
interp.rast.3<-machisplin.mltps(int.values=tile$dat[[3]], covar.ras=tile$rast[[3]], tps=TRUE)
interp.rast.4<-machisplin.mltps(int.values=tile$dat[[4]], covar.ras=tile$rast[[4]], tps=TRUE)

## create a dataset with output rasters - IN SPECIFIC ORDER (see below)
##note that these rasters MUST be ordered to match the layout matching machisplin.tiles.id and MUST be stored as shown below (with a space between stored raster (final.raster.name [[1]], and NOT as: final.raster.name[[1]]). 
final.rast [[1]]<-interp.rast.1[[1]]$final
final.rast [[2]]<-interp.rast.2[[1]]$final
final.rast [[3]]<-interp.rast.3[[1]]$final
final.rast [[4]]<-interp.rast.4[[1]]$final

machisplin.merge.tiles<-function(rast.in=final.rast, rast.full.ext=ALT, in.ncol=tile$nC, in.nrow=tile$nR)

########################################EXAMPLE 2################################################
library(MACHISPLIN)

# Import a csv 
Mydata	<-read.delim("sampling.csv", sep=",", h=T)

#load rasters to use as high resolution co-variates for downscaling
ALT = rast("SRTM30m.tif")
SLOPE = rast("ln_slope.tif")
ASPECT = rast("aspect.tif")
TWI = rast("TWI.tif")

# function input: raster stack of covarites
raster_stack<-c(ALT,SLOPE,TWI,ASPECT)

#sub-divide landscape into smaller units to facilite downscaling
tile<-machisplin.tiles.create(rast.in= raster_stack, int.values=Mydata,out.ncol=2, out.nrow=2, feather.d=50)

#run an ensemble machine learning thin plate spline - tile 1:4
interp.rast.1<-machisplin.mltps(int.values=tile$dat[[1]], covar.ras=tile$rast[[1]], tps=TRUE)
interp.rast.2<-machisplin.mltps(int.values=tile$dat[[2]], covar.ras=tile$rast[[2]], tps=TRUE)
interp.rast.3<-machisplin.mltps(int.values=tile$dat[[3]], covar.ras=tile$rast[[3]], tps=TRUE)
interp.rast.4<-machisplin.mltps(int.values=tile$dat[[4]], covar.ras=tile$rast[[4]], tps=TRUE)

##note that these rasters MUST be ordered to match the layout matching machisplin.tiles.id and MUST be stored as shown below (with a space between stored raster (final.raster.name [[1]], and NOT as: final.raster.name[[1]]). 
final.rast [[1]]<-interp.rast.1[[1]]$final
final.rast [[2]]<-interp.rast.2[[1]]$final
final.rast [[3]]<-interp.rast.3[[1]]$final
final.rast [[4]]<-interp.rast.4[[1]]$final


# n of iterpolations - subtrack x and y
i.lyrs<-ncol(tile$dat)-2

# n of tiles to loop through
j.lyrs<-terra::nlyrs(tile$rast)

# a simple loop to iterate through your tiled datafile, and as it finishes layers, it saves them.  This is nice in the event of errors 
for (i in 1:i.lyrs){
     for (j in 1:j.lyrs){
	  	Mydat<-cbind(Mydata[1:2],Mydata[i+2])
	MyRast<-tile$rast[[j]]
     interp.out<-machisplin.mltps(int.values=Mydat, covar.ras=MyRast, smooth.outputs.only=TRUE, tps=TRUE)
	interp.rast[[j]]<- interp.out[[1]]$final
	 	}   
   final.inter<-machisplin.tiles.merge(rast.in=interp.rast, rast.full.ext=ALT, in.ncol=tile$nC, in.nrow=tile$nR)
  machisplin.write.geotiff(mltps.in=final.inter)
	  machisplin.write.residuals(mltps.in=final.inter)
   machisplin.write.loadings(mltps.in=final.inter)
  }

}
